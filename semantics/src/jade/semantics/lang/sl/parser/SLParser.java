/* Generated By:JavaCC: Do not edit this line. SLParser.java */
package jade.semantics.lang.sl.parser;

import jade.semantics.lang.sl.grammar.*;
import jade.semantics.lang.sl.grammar.operations.*;

//=============================================================
//                      Parser declaration
//=============================================================
public class SLParser implements SLParserConstants {
  static final String META_EXCEPTION_MESSAGE            = "Meta SL expressions are not allowed";
  static final String INVALID_PREDICATE_MESSAGE         = "Invalid predicate";
  static final String INVALID_REFERENCE_CONTEXT_MESSAGE = "Invalid context for reference";

  static final int FUNCTIONNAL_TERM                     = 0;
  static final int PREDICATE                            = 1;

  static final int CONTENT_EXPRESSION_REFERENCE         = 0;
  static final int ACTION_EXPRESSION_REFERENCE          = 1;
  static final int FORMULA_REFERENCE                    = 2;
  static final int SYMBOL_REFERENCE                     = 3;
  static final int TERM_REFERENCE                       = 4;
  static final int VARIABLE_REFERENCE                   = 5;

  //------------------------------------------------------------
  // SLParser is a singleton
  //------------------------------------------------------------
  static SLParser _instance = null;

  static public SLParser getParser()
  {
      if ( _instance == null ) {
          _instance = new SLParser();
      }
      return _instance;
  }

  //------------------------------------------------------------
  // SLParser as a SLParser
  //------------------------------------------------------------
  boolean _extented = false;

  public SLParser()
  {
      this(new java.io.InputStreamReader(System.in));
  }

  public synchronized Content parseContent(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return Content();
  }

  public synchronized Content parseContent(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(stream, false);
  }

  public synchronized Content parseContent(String content, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(new java.io.StringReader(content), extented);
  }

  public synchronized Content parseContent(String content)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(new java.io.StringReader(content));
  }

  public synchronized FunctionalTerm parseAgent(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return (FunctionalTerm)FunctionalTermOrPredicate(FUNCTIONNAL_TERM);
  }

  public synchronized FunctionalTerm parseAgent(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(stream, false);
  }

  public synchronized FunctionalTerm parseAgent(String term, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(new java.io.StringReader(term), extented);
  }

  public synchronized FunctionalTerm parseAgent(String term)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(new java.io.StringReader(term));
  }

  public synchronized Term parseTerm(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return Term();
  }

  public synchronized Term parseTerm(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(stream, false);
  }

  public synchronized Term parseTerm(String term, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(new java.io.StringReader(term), extented);
  }

  public synchronized Term parseTerm(String term)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(new java.io.StringReader(term));
  }

  public synchronized Formula parseFormula(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return Formula();
  }

  public synchronized Formula parseFormula(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(stream, false);
  }

  public synchronized Formula parseFormula(String formula, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(new java.io.StringReader(formula), extented);
  }

  public synchronized Formula parseFormula(String formula)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(new java.io.StringReader(formula));
  }

//=============================================================
//                       Rules declaration
//=============================================================

// -------------------------------------------------------------
  final public Content Content() throws ParseException {
    ContentNode content = new ContentNode(new ListOfContentExpression());
    ContentExpression expression;
    jj_consume_token(OPEN_BRACKET);
    label_1:
    while (true) {
      expression = ContentExpression();
             content.as_expressions().add(expression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case EQUALSKW:
      case SEMICOLONKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case ACTIONKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(CLOSE_BRACKET);
        {if (true) return content;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ContentExpression ContentExpression() throws ParseException {
    ActionExpression action_expression;
    IdentifyingExpression identifying_expression;
    Formula formula;
    if (jj_2_1(2)) {
      action_expression = ActionExpression();
        if ( action_expression instanceof MetaActionExpressionReferenceNode ) {
                {if (true) return new MetaContentExpressionReferenceNode(((MetaActionExpressionReferenceNode)action_expression).lx_name());}
        }
        else {
            {if (true) return new ActionContentExpressionNode(action_expression);}
        }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALLKW:
      case ANYKW:
      case IOTAKW:
        identifying_expression = IdentifyingExpression();
        {if (true) return new IdentifyingContentExpressionNode(identifying_expression);}
        break;
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula();
        if ( formula instanceof MetaFormulaReferenceNode ) {
                {if (true) return new MetaContentExpressionReferenceNode(((MetaFormulaReferenceNode )formula).lx_name());}
        }
        else {
            {if (true) return new FormulaContentExpressionNode(formula);}
        }
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ActionExpression ActionExpression() throws ParseException {
    ActionExpression action_expression;
    ActionExpression left_action_expression;
    ActionExpression right_action_expression;
    Term agent;
    Term term;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(ACTION_EXPRESSION_REFERENCE);
         {if (true) return (MetaActionExpressionReferenceNode)meta;}
      break;
    case ACTIONKW:
      jj_consume_token(ACTIONKW);
      agent = Term();
      term = Term();
      jj_consume_token(CLOSE_BRACKET);
         {if (true) return new ActionExpressionNode(agent, term);}
      break;
    case PIPEKW:
      jj_consume_token(PIPEKW);
      left_action_expression = ActionExpression();
      right_action_expression = ActionExpression();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new AlternativeActionExpressionNode(left_action_expression, right_action_expression);}
      break;
    case SEMICOLONKW:
      jj_consume_token(SEMICOLONKW);
      left_action_expression = ActionExpression();
      right_action_expression = ActionExpression();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new SequenceActionExpressionNode(left_action_expression, right_action_expression);}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public IdentifyingExpression IdentifyingExpression() throws ParseException {
    IdentifyingExpression identifying_expression;
    Term term;
    Formula formula;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IOTAKW:
      jj_consume_token(IOTAKW);
      term = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
          {if (true) return new IotaNode(term, formula);}
      break;
    case ALLKW:
      jj_consume_token(ALLKW);
      term = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
          {if (true) return new AllNode(term, formula);}
      break;
    case ANYKW:
      jj_consume_token(ANYKW);
      term = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
          {if (true) return new AnyNode(term, formula);}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Formula Formula() throws ParseException {
    AtomicFormula atomic_formula;
    ActionFormula action_formula;
    ActionExpression action_expression;
    Formula formula = null;
    Formula left_formula;
    Formula right_formula;
    Term agent;
    Variable variable;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case EQUALSKW:
    case TRUEKW:
    case FALSEKW:
    case RESULTKW:
    case META_VARIABLE:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      atomic_formula = AtomicFormula();
         if ( atomic_formula instanceof PropositionSymbolNode &&
              ((PropositionSymbolNode)atomic_formula).as_symbol() instanceof MetaSymbolReferenceNode ) {
             MetaSymbolReferenceNode s = (MetaSymbolReferenceNode)((PropositionSymbolNode)atomic_formula).as_symbol();
             {if (true) return new MetaFormulaReferenceNode(s.lx_name());}
         }
         else {
             {if (true) return atomic_formula;}
         }
      break;
    case DONEKW:
      jj_consume_token(DONEKW);
      action_expression = ActionExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new DoneNode(action_expression, formula==null?new TrueNode():formula);}
      break;
    case FEASIBLEKW:
      jj_consume_token(FEASIBLEKW);
      action_expression = ActionExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula();
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new FeasibleNode(action_expression, formula==null?new TrueNode():formula);}
      break;
    case NOTKW:
      jj_consume_token(NOTKW);
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new NotNode(formula);}
      break;
    case ANDKW:
      jj_consume_token(ANDKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new AndNode(left_formula, right_formula);}
      break;
    case ORKW:
      jj_consume_token(ORKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new OrNode(left_formula, right_formula);}
      break;
    case IMPLIESKW:
      jj_consume_token(IMPLIESKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ImpliesNode(left_formula, right_formula);}
      break;
    case EQUIVKW:
      jj_consume_token(EQUIVKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new EquivNode(left_formula, right_formula);}
      break;
    case EXISTSKW:
      jj_consume_token(EXISTSKW);
      variable = Variable();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ExistsNode(variable, formula);}
      break;
    case FORALLKW:
      jj_consume_token(FORALLKW);
      variable = Variable();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ForallNode(variable, formula);}
      break;
    case BELIEVEKW:
      jj_consume_token(BELIEVEKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new BelieveNode(agent, formula);}
      break;
    case UNCERTAINTYKW:
      jj_consume_token(UNCERTAINTYKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new UncertaintyNode(agent, formula);}
      break;
    case INTENTIONKW:
      jj_consume_token(INTENTIONKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new IntentionNode(agent, formula);}
      break;
    case PERSISTENTGOALKW:
      jj_consume_token(PERSISTENTGOALKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new PersistentGoalNode(agent, formula);}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public AtomicFormula AtomicFormula() throws ParseException {
    AtomicFormula atomic_formula;
    Node predicate;
    ListOfTerm terms;
    Symbol symbol;
    Term term1, term2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      symbol = Symbol();
        {if (true) return new PropositionSymbolNode(symbol);}
      break;
    case RESULTKW:
      jj_consume_token(RESULTKW);
      term1 = Term();
      term2 = Term();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ResultNode(term1, term2);}
      break;
    case EQUALSKW:
      jj_consume_token(EQUALSKW);
      term1 = Term();
      term2 = Term();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new EqualsNode(term1, term2);}
      break;
    case OPEN_BRACKET:
      predicate = FunctionalTermOrPredicate(PREDICATE);
        {if (true) return (PredicateNode)predicate;}
      break;
    case TRUEKW:
      jj_consume_token(TRUEKW);
        TrueNode trueNode = new TrueNode();
        trueNode.sm_simplified_formula(trueNode);
        {if (true) return trueNode;}
      break;
    case FALSEKW:
      jj_consume_token(FALSEKW);
        FalseNode falseNode = new FalseNode();
        falseNode.sm_simplified_formula(falseNode);
        {if (true) return falseNode;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ListOfTerm Terms() throws ParseException {
    ListOfTerm terms = new ListOfTerm();
    Term term;
    label_2:
    while (true) {
      term = Term();
        terms.add(term);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case SEMICOLONKW:
      case SETKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case ACTIONKW:
      case SEQUENCEKW:
      case VARIABLE:
      case META_VARIABLE:
      case INTEGER:
      case FLOAT:
      case DATE_TIME:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_2;
      }
    }
       {if (true) return terms;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Symbol Symbol() throws ParseException {
    java.lang.String symbolName;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(SYMBOL_REFERENCE);
         {if (true) return (MetaSymbolReferenceNode)meta;}
      break;
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      symbolName = String();
        {if (true) return new SymbolNode(symbolName);}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Term Term() throws ParseException {
    Constant constant;
    TermSet term_set;
    TermSequence term_sequence;
    Node functional_term;
    ActionExpression action_expression;
    IdentifyingExpression identifying_expression;
    Variable variable;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      constant = Constant();
        {if (true) return constant;}
      break;
    case SETKW:
      term_set = TermSet();
        {if (true) return term_set;}
      break;
    case SEQUENCEKW:
      term_sequence = TermSequence();
        {if (true) return term_sequence;}
      break;
    case OPEN_BRACKET:
      functional_term = FunctionalTermOrPredicate(FUNCTIONNAL_TERM);
        {if (true) return (FunctionalTerm)functional_term;}
      break;
    default:
      jj_la1[10] = jj_gen;
      if (jj_2_2(2)) {
        action_expression = ActionExpression();
         if ( action_expression instanceof MetaActionExpressionReferenceNode ) {
             {if (true) return new MetaTermReferenceNode(((MetaActionExpressionReferenceNode)action_expression).lx_name());}
         }
         else {
             {if (true) return action_expression;}
         }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALLKW:
        case ANYKW:
        case IOTAKW:
          identifying_expression = IdentifyingExpression();
        {if (true) return identifying_expression;}
          break;
        case VARIABLE:
        case META_VARIABLE:
          variable = Variable();
         if ( variable instanceof MetaVariableReferenceNode ) {
             {if (true) return new MetaTermReferenceNode(((MetaVariableReferenceNode)variable).lx_name());}
         }
         else {
             {if (true) return variable;}
         }
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Constant Constant() throws ParseException {
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
        String s = token.image.substring(1,token.image.length()-1);
        String value = new String();
        for (int i=0; i<s.length(); i++) {
            if ( i<s.length()-1 &&
                 s.charAt(i) == '\\' &&
                 (s.charAt(i+1) == '\"' || s.charAt(i+1) == '\\' ) ) {
                i++;
            }
            value += s.charAt(i);
        }
        {if (true) return new StringConstantNode(value);}
      break;
    case WORD:
      token = jj_consume_token(WORD);
        {if (true) return new WordConstantNode(token.image);}
      break;
    case BYTES:
      token = jj_consume_token(BYTES);
        int n = Integer.parseInt(token.image.substring(1, token.image.length()-1));
        System.err.println(n);
        byte[] bytes = new byte[n];
        try {
            for (int i=0; i<n;i++) {bytes[i] = (byte)jj_input_stream.readChar();}
        }
        catch(Exception e) {}
        {if (true) return new ByteConstantNode(token.image+new String(bytes));}
      break;
    case FLOAT:
      token = jj_consume_token(FLOAT);
        {if (true) return new RealConstantNode(new Double(token.image));}
      break;
    case INTEGER:
      token = jj_consume_token(INTEGER);
        {if (true) return new IntegerConstantNode(new Long(token.image));}
      break;
    case DATE_TIME:
      token = jj_consume_token(DATE_TIME);
        {if (true) return new DateTimeConstantNode(token.image);}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public String String() throws ParseException {
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
        {if (true) return token.image;}
      break;
    case BYTES:
      token = jj_consume_token(BYTES);
        {if (true) return token.image;}
      break;
    case WORD:
      token = jj_consume_token(WORD);
        {if (true) return token.image;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public TermSet TermSet() throws ParseException {
    ListOfTerm terms = null;
    jj_consume_token(SETKW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      terms = Terms();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
         {if (true) return new TermSetNode(terms==null ? new ListOfTerm() : terms);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public TermSequence TermSequence() throws ParseException {
    ListOfTerm terms = null;
    jj_consume_token(SEQUENCEKW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      terms = Terms();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
         {if (true) return new TermSequenceNode(terms==null ? new ListOfTerm() : terms);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Node FunctionalTermOrPredicate(int which) throws ParseException {
    Symbol symbol;
    ListOfTerm terms = null;
    ListOfParameter parameters = null;
    jj_consume_token(OPEN_BRACKET);
    symbol = Symbol();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case PARAMETER_NAME:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case SEMICOLONKW:
      case SETKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case ACTIONKW:
      case SEQUENCEKW:
      case VARIABLE:
      case META_VARIABLE:
      case INTEGER:
      case FLOAT:
      case DATE_TIME:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        terms = Terms();
        break;
      case PARAMETER_NAME:
        parameters = Parameters();
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
        if ( which == FUNCTIONNAL_TERM ) {
            if ( parameters == null ) {
                {if (true) return new FunctionalTermNode(symbol, terms==null ? new ListOfTerm() : terms);}
            }
            else {
                {if (true) return new FunctionalTermParamNode(symbol, parameters);}
            }
        }
        else /* which == PREDICATE */ {
            if ( parameters == null ) {
                {if (true) return new PredicateNode(symbol, terms==null ? new ListOfTerm() : terms);}
            }
            else {
                {if (true) throw new ParseException(INVALID_PREDICATE_MESSAGE);}
            }
        }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ListOfParameter Parameters() throws ParseException {
    ListOfParameter parameters = new ListOfParameter();
    Parameter parameter;
    label_3:
    while (true) {
      parameter = Parameter();
        parameters.add(parameter);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAMETER_NAME:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_3;
      }
    }
       {if (true) return parameters;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Parameter Parameter() throws ParseException {
    Parameter parameter;
    Token token;
    Term term;
    token = jj_consume_token(PARAMETER_NAME);
    term = Term();
         {if (true) return new ParameterNode(term, token.image);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Variable Variable() throws ParseException {
    java.lang.String variableName;
    Node meta;
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(VARIABLE_REFERENCE);
         {if (true) return (MetaVariableReferenceNode)meta;}
      break;
    case VARIABLE:
      token = jj_consume_token(VARIABLE);
        {if (true) return new VariableNode(token.image);}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Node MetaVariable(int which) throws ParseException {
    Token token;
    token = jj_consume_token(META_VARIABLE);
         if ( !_extented ) {{if (true) throw new ParseException(META_EXCEPTION_MESSAGE);}}
         if ( which == CONTENT_EXPRESSION_REFERENCE ) {
             {if (true) return new MetaContentExpressionReferenceNode(token.image);}
         }
         else if ( which == ACTION_EXPRESSION_REFERENCE ) {
             {if (true) return new MetaActionExpressionReferenceNode(token.image);}
         }
         else if ( which == FORMULA_REFERENCE ) {
             {if (true) return new MetaFormulaReferenceNode(token.image);}
         }
         else if ( which == SYMBOL_REFERENCE ) {
             {if (true) return new MetaSymbolReferenceNode(token.image);}
         }
         else if ( which == TERM_REFERENCE ) {
             {if (true) return new MetaTermReferenceNode(token.image);}
         }
         else if ( which == VARIABLE_REFERENCE ) {
             {if (true) return new MetaVariableReferenceNode(token.image);}
         }
         else {
             {if (true) throw new ParseException(INVALID_REFERENCE_CONTEXT_MESSAGE);}
         }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_3R_31() {
    if (jj_scan_token(ANYKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_4()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_3R_9()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_scan_token(WORD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(ALLKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_3R_20()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(IOTAKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_3R_18()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_8() {
    if (jj_scan_token(SEMICOLONKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_4()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_4()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(DATE_TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_7() {
    if (jj_scan_token(PIPEKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_4()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_scan_token(SEQUENCEKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(INTEGER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_6() {
    if (jj_scan_token(ACTIONKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_10()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_9() {
    if (jj_scan_token(META_VARIABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(FLOAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_3R_22()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_5() {
    if (jj_3R_9()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_5()) {
    jj_scanpos = xsp;
    if (jj_3R_6()) {
    jj_scanpos = xsp;
    if (jj_3R_7()) {
    jj_scanpos = xsp;
    if (jj_3R_8()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_scan_token(SETKW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(VARIABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(BYTES)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public SLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  final private int[] jj_la1_0 = {0xfff7fe80,0xf7f7f480,0x8000a00,0x700000,0xf787f480,0xf787f480,0xf787f480,0x15000480,0x8780a80,0x0,0x80080,0x700000,0x0,0x0,0x8780a80,0x8780a80,0x8780a80,0x8780a80,0x0,0x0,};
  final private int[] jj_la1_1 = {0x700011,0x700011,0x10,0x0,0x700011,0x700011,0x700011,0x700010,0x70093a,0x700010,0x700922,0x18,0x700920,0x700000,0x70093a,0x70093a,0x70093e,0x70093e,0x4,0x18,};
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public SLParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SLParser(SLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(SLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enu = jj_expentries.elements(); enu.hasMoreElements();) {
        int[] oldentry = (int[])(enu.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[56];
    for (int i = 0; i < 56; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 56; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
