/* Generated By:JavaCC: Do not edit this line. SLParser.java */
package jade.semantics.lang.sl.parser;

import jade.semantics.lang.sl.grammar.*;
import jade.semantics.lang.sl.grammar.operations.*;

//=============================================================
//                      Parser declaration
//=============================================================
public class SLParser implements SLParserConstants {
  static final String META_EXCEPTION_MESSAGE            = "Meta SL expressions are not allowed";
  static final String INVALID_PREDICATE_MESSAGE         = "Invalid predicate";
  static final String INVALID_REFERENCE_CONTEXT_MESSAGE = "Invalid context for reference";

  static final int FUNCTIONNAL_TERM                     = 0;
  static final int PREDICATE                            = 1;

  static final int CONTENT_EXPRESSION_REFERENCE         = 0;
  static final int FORMULA_REFERENCE                    = 1;
  static final int SYMBOL_REFERENCE                     = 2;
  static final int TERM_REFERENCE                       = 3;
  static final int VARIABLE_REFERENCE                   = 4;

  static public final java.text.SimpleDateFormat DATE_FORMAT = new java.text.SimpleDateFormat("yyyyMMdd'T'HHmmssSSS");

  //------------------------------------------------------------
  // SLParser is a singleton
  //------------------------------------------------------------
  static SLParser _instance = null;

  static public SLParser getParser()
  {
      if ( _instance == null ) {
          _instance = new SLParser();
      }
      return _instance;
  }

  //------------------------------------------------------------
  // SLParser as a SLParser
  //------------------------------------------------------------
  boolean _extented = false;

  public SLParser()
  {
      this(new java.io.InputStreamReader(System.in));
  }

  public synchronized Content parseContent(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return Content();
  }

  public synchronized Content parseContent(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(stream, false);
  }

  public synchronized Content parseContent(String content, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(new java.io.StringReader(content), extented);
  }

  public synchronized Content parseContent(String content)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(new java.io.StringReader(content));
  }

  public synchronized FunctionalTerm parseAgent(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return (FunctionalTerm)FunctionalTermOrPredicate(FUNCTIONNAL_TERM);
  }

  public synchronized FunctionalTerm parseAgent(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(stream, false);
  }

  public synchronized FunctionalTerm parseAgent(String term, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(new java.io.StringReader(term), extented);
  }

  public synchronized FunctionalTerm parseAgent(String term)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(new java.io.StringReader(term));
  }

  public synchronized Term parseTerm(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return Term();
  }

  public synchronized Term parseTerm(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(stream, false);
  }

  public synchronized Term parseTerm(String term, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(new java.io.StringReader(term), extented);
  }

  public synchronized Term parseTerm(String term)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(new java.io.StringReader(term));
  }

  public synchronized Formula parseFormula(java.io.Reader stream, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      _extented = extented;
      return Formula();
  }

  public synchronized Formula parseFormula(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(stream, false);
  }

  public synchronized Formula parseFormula(String formula, boolean extented)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(new java.io.StringReader(formula), extented);
  }

  public synchronized Formula parseFormula(String formula)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(new java.io.StringReader(formula));
  }

//=============================================================
//                       Rules declaration
//=============================================================

// -------------------------------------------------------------
  final public Content Content() throws ParseException {
    ContentNode content = new ContentNode(new ListOfContentExpression());
    ContentExpression expression;
    jj_consume_token(OPEN_BRACKET);
    label_1:
    while (true) {
      expression = ContentExpression();
             content.as_expressions().add(expression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case EQUALSKW:
      case SEMICOLONKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case ACTIONKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(CLOSE_BRACKET);
        {if (true) return content;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ContentExpression ContentExpression() throws ParseException {
    ActionExpression action_expression;
    IdentifyingExpression identifying_expression;
    Formula formula;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(CONTENT_EXPRESSION_REFERENCE);
           {if (true) return (MetaContentExpressionReferenceNode)meta;}
      break;
    case PIPEKW:
    case SEMICOLONKW:
    case ACTIONKW:
      action_expression = ActionExpression();
            {if (true) return new ActionContentExpressionNode(action_expression);}
      break;
    case ALLKW:
    case ANYKW:
    case IOTAKW:
      identifying_expression = IdentifyingExpression();
        {if (true) return new IdentifyingContentExpressionNode(identifying_expression);}
      break;
    case OPEN_BRACKET:
    case EQUALSKW:
    case BELIEVEKW:
    case UNCERTAINTYKW:
    case INTENTIONKW:
    case PERSISTENTGOALKW:
    case ORKW:
    case ANDKW:
    case NOTKW:
    case DONEKW:
    case TRUEKW:
    case EQUIVKW:
    case FALSEKW:
    case RESULTKW:
    case EXISTSKW:
    case FORALLKW:
    case IMPLIESKW:
    case FEASIBLEKW:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      formula = Formula();
            {if (true) return new FormulaContentExpressionNode(formula);}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ActionExpression ActionExpression() throws ParseException {
    Term left_action;
    Term right_action;
    Term agent;
    Term term;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACTIONKW:
      jj_consume_token(ACTIONKW);
      agent = Term();
      term = Term();
      jj_consume_token(CLOSE_BRACKET);
         {if (true) return new ActionExpressionNode(agent, term);}
      break;
    case PIPEKW:
      jj_consume_token(PIPEKW);
      left_action = Term();
      right_action = Term();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new AlternativeActionExpressionNode(left_action, right_action);}
      break;
    case SEMICOLONKW:
      jj_consume_token(SEMICOLONKW);
      left_action = Term();
      right_action = Term();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new SequenceActionExpressionNode(left_action, right_action);}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public IdentifyingExpression IdentifyingExpression() throws ParseException {
    IdentifyingExpression identifying_expression;
    Term term;
    Formula formula;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IOTAKW:
      jj_consume_token(IOTAKW);
      term = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
          {if (true) return new IotaNode(term, formula);}
      break;
    case ALLKW:
      jj_consume_token(ALLKW);
      term = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
          {if (true) return new AllNode(term, formula);}
      break;
    case ANYKW:
      jj_consume_token(ANYKW);
      term = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
          {if (true) return new AnyNode(term, formula);}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Formula Formula() throws ParseException {
    AtomicFormula atomic_formula;
    Term action;
    Formula formula = null;
    Formula left_formula;
    Formula right_formula;
    Term agent;
    Variable variable;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(FORMULA_REFERENCE);
           {if (true) return (MetaFormulaReferenceNode)meta;}
      break;
    case OPEN_BRACKET:
    case EQUALSKW:
    case TRUEKW:
    case FALSEKW:
    case RESULTKW:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      atomic_formula = AtomicFormula();
             {if (true) return atomic_formula;}
      break;
    case DONEKW:
      jj_consume_token(DONEKW);
      action = Term();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new DoneNode(action, formula==null?new TrueNode():formula);}
      break;
    case FEASIBLEKW:
      jj_consume_token(FEASIBLEKW);
      action = Term();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula();
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new FeasibleNode(action, formula==null?new TrueNode():formula);}
      break;
    case NOTKW:
      jj_consume_token(NOTKW);
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new NotNode(formula);}
      break;
    case ANDKW:
      jj_consume_token(ANDKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new AndNode(left_formula, right_formula);}
      break;
    case ORKW:
      jj_consume_token(ORKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new OrNode(left_formula, right_formula);}
      break;
    case IMPLIESKW:
      jj_consume_token(IMPLIESKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ImpliesNode(left_formula, right_formula);}
      break;
    case EQUIVKW:
      jj_consume_token(EQUIVKW);
      left_formula = Formula();
      right_formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new EquivNode(left_formula, right_formula);}
      break;
    case EXISTSKW:
      jj_consume_token(EXISTSKW);
      variable = Variable();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ExistsNode(variable, formula);}
      break;
    case FORALLKW:
      jj_consume_token(FORALLKW);
      variable = Variable();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ForallNode(variable, formula);}
      break;
    case BELIEVEKW:
      jj_consume_token(BELIEVEKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new BelieveNode(agent, formula);}
      break;
    case UNCERTAINTYKW:
      jj_consume_token(UNCERTAINTYKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new UncertaintyNode(agent, formula);}
      break;
    case INTENTIONKW:
      jj_consume_token(INTENTIONKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new IntentionNode(agent, formula);}
      break;
    case PERSISTENTGOALKW:
      jj_consume_token(PERSISTENTGOALKW);
      agent = Term();
      formula = Formula();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new PersistentGoalNode(agent, formula);}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public AtomicFormula AtomicFormula() throws ParseException {
    AtomicFormula atomic_formula;
    Node predicate;
    ListOfTerm terms;
    Symbol symbol;
    Term term1, term2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      symbol = Symbol();
        {if (true) return new PropositionSymbolNode(symbol);}
      break;
    case RESULTKW:
      jj_consume_token(RESULTKW);
      term1 = Term();
      term2 = Term();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ResultNode(term1, term2);}
      break;
    case EQUALSKW:
      jj_consume_token(EQUALSKW);
      term1 = Term();
      term2 = Term();
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new EqualsNode(term1, term2);}
      break;
    case OPEN_BRACKET:
      predicate = FunctionalTermOrPredicate(PREDICATE);
        {if (true) return (PredicateNode)predicate;}
      break;
    case TRUEKW:
      jj_consume_token(TRUEKW);
        TrueNode trueNode = new TrueNode();
        trueNode.sm_simplified_formula(trueNode);
        {if (true) return trueNode;}
      break;
    case FALSEKW:
      jj_consume_token(FALSEKW);
        FalseNode falseNode = new FalseNode();
        falseNode.sm_simplified_formula(falseNode);
        {if (true) return falseNode;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ListOfTerm Terms() throws ParseException {
    ListOfTerm terms = new ListOfTerm();
    Term term;
    label_2:
    while (true) {
      term = Term();
        terms.add(term);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case SEMICOLONKW:
      case SETKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case ACTIONKW:
      case SEQUENCEKW:
      case VARIABLE:
      case META_VARIABLE:
      case INTEGER:
      case FLOAT:
      case DATE_TIME:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_2;
      }
    }
       {if (true) return terms;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Symbol Symbol() throws ParseException {
    java.lang.String symbolName;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(SYMBOL_REFERENCE);
         {if (true) return (MetaSymbolReferenceNode)meta;}
      break;
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      symbolName = String();
        {if (true) return new SymbolNode(symbolName);}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Term Term() throws ParseException {
    Constant constant;
    TermSet term_set;
    TermSequence term_sequence;
    Node functional_term;
    ActionExpression action_expression;
    IdentifyingExpression identifying_expression;
    Variable variable;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(TERM_REFERENCE);
         {if (true) return (MetaTermReferenceNode)meta;}
      break;
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      constant = Constant();
        {if (true) return constant;}
      break;
    case SETKW:
      term_set = TermSet();
        {if (true) return term_set;}
      break;
    case SEQUENCEKW:
      term_sequence = TermSequence();
        {if (true) return term_sequence;}
      break;
    case OPEN_BRACKET:
      functional_term = FunctionalTermOrPredicate(FUNCTIONNAL_TERM);
        {if (true) return (FunctionalTerm)functional_term;}
      break;
    case PIPEKW:
    case SEMICOLONKW:
    case ACTIONKW:
      action_expression = ActionExpression();
            {if (true) return action_expression;}
      break;
    case ALLKW:
    case ANYKW:
    case IOTAKW:
      identifying_expression = IdentifyingExpression();
        {if (true) return identifying_expression;}
      break;
    case VARIABLE:
      variable = Variable();
             {if (true) return variable;}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Constant Constant() throws ParseException {
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
        String s = token.image.substring(1,token.image.length()-1);
        String value = new String();
        for (int i=0; i<s.length(); i++) {
            if ( i<s.length()-1 &&
                 s.charAt(i) == '\\' &&
                 (s.charAt(i+1) == '\"' || s.charAt(i+1) == '\\' ) ) {
                i++;
            }
            value += s.charAt(i);
        }
        {if (true) return new StringConstantNode(value);}
      break;
    case WORD:
      token = jj_consume_token(WORD);
        {if (true) return new WordConstantNode(token.image);}
      break;
    case BYTES:
      token = jj_consume_token(BYTES);
        int n = Integer.parseInt(token.image.substring(1, token.image.length()-1));
                Byte[] bytes = new Byte[n];
                try {
                    for (int i=0; i<n;i++) {bytes[i] = (byte)jj_input_stream.readChar();}
                }
                catch(Exception e) {e.printStackTrace();}
                {if (true) return new ByteConstantNode(bytes);}
      break;
    case FLOAT:
      token = jj_consume_token(FLOAT);
        {if (true) return new RealConstantNode(new Double(token.image));}
      break;
    case INTEGER:
      token = jj_consume_token(INTEGER);
        {if (true) return new IntegerConstantNode(new Long(token.image));}
      break;
    case DATE_TIME:
      token = jj_consume_token(DATE_TIME);
        try {
                {if (true) return new DateTimeConstantNode(DATE_FORMAT.parse(token.image));}
        }
        catch (Exception e) {e.printStackTrace();}
        {if (true) return null;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public String String() throws ParseException {
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
        {if (true) return token.image;}
      break;
    case BYTES:
      token = jj_consume_token(BYTES);
        {if (true) return token.image;}
      break;
    case WORD:
      token = jj_consume_token(WORD);
        {if (true) return token.image;}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public TermSet TermSet() throws ParseException {
    ListOfTerm terms = null;
    jj_consume_token(SETKW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      terms = Terms();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
         {if (true) return new TermSetNode(terms==null ? new ListOfTerm() : terms);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public TermSequence TermSequence() throws ParseException {
    ListOfTerm terms = null;
    jj_consume_token(SEQUENCEKW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      terms = Terms();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
         {if (true) return new TermSequenceNode(terms==null ? new ListOfTerm() : terms);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Node FunctionalTermOrPredicate(int which) throws ParseException {
    Symbol symbol;
    ListOfTerm terms = null;
    ListOfParameter parameters = null;
    jj_consume_token(OPEN_BRACKET);
    symbol = Symbol();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case METAOPTIONKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case PARAMETER_NAME:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case SEMICOLONKW:
      case SETKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case ACTIONKW:
      case SEQUENCEKW:
      case VARIABLE:
      case META_VARIABLE:
      case INTEGER:
      case FLOAT:
      case DATE_TIME:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        terms = Terms();
        break;
      case METAOPTIONKW:
      case PARAMETER_NAME:
        parameters = Parameters();
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
        if ( which == FUNCTIONNAL_TERM ) {
            if ( terms == null ) {
                        {if (true) return new FunctionalTermParamNode(symbol, parameters==null ? new ListOfParameter() : parameters);}
            }
            else {
                        {if (true) return new FunctionalTermNode(symbol, terms);}
            }
        }
        else /* which == PREDICATE */ {
            if ( parameters == null ) {
                        {if (true) return new PredicateNode(symbol, terms==null ? new ListOfTerm() : terms);}
            }
            else {
                        {if (true) throw new ParseException(INVALID_PREDICATE_MESSAGE);}
            }
        }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ListOfParameter Parameters() throws ParseException {
    ListOfParameter parameters = new ListOfParameter();
    Parameter parameter;
    label_3:
    while (true) {
      parameter = Parameter();
        parameters.add(parameter);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case METAOPTIONKW:
      case PARAMETER_NAME:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_3;
      }
    }
       {if (true) return parameters;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Parameter Parameter() throws ParseException {
    Parameter parameter;
    Token token;
    Term term;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAMETER_NAME:
      token = jj_consume_token(PARAMETER_NAME);
      term = Term();
          {if (true) return new ParameterNode(term, token.image.substring(1), Boolean.FALSE);}
      break;
    case METAOPTIONKW:
      jj_consume_token(METAOPTIONKW);
      token = jj_consume_token(PARAMETER_NAME);
      term = Term();
      jj_consume_token(CLOSE_BRACKET);
                if ( !_extented ) {{if (true) throw new ParseException(META_EXCEPTION_MESSAGE);}}
                {if (true) return new ParameterNode(term, token.image.substring(1), Boolean.TRUE);}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Variable Variable() throws ParseException {
    java.lang.String variableName;
    Node meta;
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(VARIABLE_REFERENCE);
         {if (true) return (MetaVariableReferenceNode)meta;}
      break;
    case VARIABLE:
      token = jj_consume_token(VARIABLE);
        {if (true) return new VariableNode(token.image.substring(1));}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Node MetaVariable(int which) throws ParseException {
    Token token;
    token = jj_consume_token(META_VARIABLE);
         if ( !_extented ) {{if (true) throw new ParseException(META_EXCEPTION_MESSAGE);}}
         if ( which == CONTENT_EXPRESSION_REFERENCE ) {
             {if (true) return new MetaContentExpressionReferenceNode(token.image.substring(2));}
         }
         else if ( which == FORMULA_REFERENCE ) {
             {if (true) return new MetaFormulaReferenceNode(token.image.substring(2));}
         }
         else if ( which == SYMBOL_REFERENCE ) {
             {if (true) return new MetaSymbolReferenceNode(token.image.substring(2));}
         }
         else if ( which == TERM_REFERENCE ) {
             {if (true) return new MetaTermReferenceNode(token.image.substring(2));}
         }
         else if ( which == VARIABLE_REFERENCE ) {
             {if (true) return new MetaVariableReferenceNode(token.image.substring(2));}
         }
         else {
             {if (true) throw new ParseException(INVALID_REFERENCE_CONTEXT_MESSAGE);}
         }
    throw new Error("Missing return statement in function");
  }

  public SLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xffdfce80,0xffdfce80,0x20000a00,0x1c00000,0xde1fc480,0xde1fc480,0xde1fc480,0x54000480,0x21e00a80,0x0,0x21e00a80,0x0,0x0,0x21e00a80,0x21e00a80,0x21e02a80,0x21e02a80,0x2000,0x2000,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1c00047,0x1c00047,0x0,0x0,0x1c00047,0x1c00047,0x1c00047,0x1c00040,0x1c024e8,0x1c00040,0x1c024e8,0x1c02480,0x1c00000,0x1c024e8,0x1c024e8,0x1c024f8,0x1c024f8,0x10,0x10,0x60,};
   }

  public SLParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public SLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public SLParser(SLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(SLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[58];
    for (int i = 0; i < 58; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 58; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
